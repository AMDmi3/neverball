
                    * SUPER EMPTY BALL MAPPING *


Super Empty Ball environments  are defined using GtkRadiant. Knowledge
of GtkRadiant is prerequisite to this document.  Users unfamiliar with
radiant usage  are encouraged to  study the radiant  documentation and
craft a  few maps  for Quake, Wolf,  or Half-Life before  attemping to
create content for SEB.

GtkRadiant, documentation, and tutorials may be found at

    http://www.qeradiant.com



* OVERVIEW

So now that we all know  everything about Quake engine mapping, we can
go ahead and  forget most of it.  SEB  mapping has significantly fewer
restrictions than  Quake mapping.   Some of the  important differences
are as follows:

  - The scale differs.  In Quake there are 8 units to a foot.  In SEB
    there are 64 units to a meter.  The default major grid in radiant
    marks 64 units, so meters are easy to work with.

  - SEB  maps need  not  be closed.   SEB  environments are  generally
    entirely visible  all of  the time, so  all the attention  paid to
    visibility by Quake becomes unnecessary.  Maps don't leak.

  - Brushes are refered to as  "lumps". They may overlap.  In fact, it
    is often advantageous to overlap lumps.

  - Shaders do not modify geometry.  The lumps you place are the lumps
    that the  ball impacts.  The  textures you apply are  the textures
    that appear in SEB.

  - No curves.  SEB physics doesn't consider them.

  - Most of  Quake's entities are meaningless  in SEB.  A  few of them
    are used, but in modified form.  These are documented below.

  - No lights.  All lighting is dynamic.


Some of what you know from Quake mapping still applies:

  - Geometry should  be "caulked" to  minimize polygon count.  In SEB,
    the caulking  texture is called "invisible" and  it appears within
    radiant as a white grid pattern.

  - T-intersections cause polygon cracks.  Avoid them.

  - Coincident faces cause Z-fighting.  This is a shooting offense.

  - Detail brushes  are a  good way to  add visual  complexity without
    adding computational complexity.



* QUICKSTART TUTORIAL

Here  we gloss  over  all the  details  and get  going  as quickly  as
possible.   For this  discussion, we  assume that  SEB is  unpacked in
$HOME/seb/.   We assume  that radiant  is installed,  but  the version
number and location is not significant.

Note that to  install radiant, you will need to have  Quake 3 Arena or
Return  to  Castle Wolfenstein  installed.   For  this discussion,  we
assume that Quake 3 Arena is installed, and that it is located in

    /usr/local/games/quake3

We must first make radiant aware of the SEB materials.

    cd /usr/local/quake3/baseq3

    ln -s $HOME/seb/data/mtrl             textures/mtrl
    ln -s $HOME/seb/data/mtrl/mtrl.shader scripts/mtrl.shader

Now, the  mtrl shaders should  appear in radiants Texture's  menu. You
may need to  set "shaderlist.txt only" to OFF  in the radiant Textures
menu.  Be sure that ONLY mtrl shaders are used for SEB maps.

At this point, you  can go ahead and create a map.   Just toss in some
brushes, plop  some mtrl shaders  down on them, nothing  fancy. Forget
the   entities    for   now,   except    drop   in   at    least   one
info_player_start.  You can  save  it anywhere,  but for  simplicities
sake, put it in:

    $HOME/seb/data/map/

When processing and testing a  map, the current directory must contain
the mtrl directory.   This is because the texture  names are stored as
relative paths in the .map and in the .sol.

    cd $HOME/seb/data

Assume the  map is named funkyball.map.   Process it into  a .sol with
the following command. Output should be similar.

    ../src/mapc funkyball.map funkyball.sol

    mtrl vert edge side texc geom lump node path body coin ball indx
      35   45   68   35  136   66    6    0    0    1    0    1  214
       3   25   48   24   29   66    6    0    0    1    0    1  214

To   test  your   map,  add   the  relative   path  and   filename  to
data/levels.txt and include the level time in seconds.  Then, run ball
as normal from the base seb directory.




* ENTITIES

Only  a few Quake  entities are  supported, and  all of  the supported
entities behave differently in some way. The SEB entities follow.  All
applicable entity attributes are documented here.

info_player_start

    The info_player_start entity  defines a ball in a  .sol file.  The
    "radius" attribute gives the ball radius in meters.  A normal ball
    radius is "0.25". The default is "1.0".

    The "origin" attribute gives the ball location.  The bottom of the
    entity in the editor will correspond  to the bottom of the ball in
    SEB.

light

    The  light entity  defines a  coin in  a .sol  file.   The "light"
    attribute  gives the  value of  the  coin.  When  placing a  light
    entity, the editor  will probably recommend a value  of 300.  This
    is far  too much.  SEB draws  coins in denominations of  1, 5, and
    10.

    The  "origin" attribute  gives  the coin  location.  Consider  the
    radius of your ball and place coins within reach from the floor.

path_corner

    The path_corner entity defines a  point along the path of a moving
    object.  The "targetname" attribute  gives the name by which other
    entities will refer to this  point.  The default name generated by
    radiant is usually fine.

    The "target"  attribute gives the  destination of the  path.  This
    attribute may be  automatically specified using radiant's "Connect
    Entities" feature.  To make a path  from point A to point B, first
    select  path_corner A,  then  select path_corner  B, then  Connect
    Entities (control-k).

    The "speed"  attribute gives  the duration of  the trip  from this
    point to  the target.   Note that this  attribute has  a different
    meaning to SEB than it does to Quake. In Quake, it gives the speed
    in units per second.  In SEB  it gives the travel time in seconds,
    regardless of  the distance between  one point and the  next.  The
    default is "1.0".

    The "origin" attribute gives the point location.

    To  create a  pause  in  a path.   Simply  position two  connected
    path_corner entities at  the same point.  The trip  will have zero
    length but the object will  still spend "speed" seconds making the
    journey.

    To  define  a level's  introductory  fly-by,  place a  path-corner
    targeting the info_player_start.

func_train

    The   func_train  entity   defines  the   geometry  of   a  moving
    object. Think  of it  as a container  or a grouping  mechanism for
    lumps, rather than an object in and of itself.

    To create a func_train, first  select all of the brushes that form
    the moving object, then  select func_train from the entities popup
    (right click) menu.

    Now, when selecting a func_train, be sure to select the group as a
    whole, rather than one of  the brushes comprising it. You may want
    to use the Entity Info dialog.

    To assign  a func_train  to a path,  first select  the func_train,
    then select the first path_corner entity of the path, then Connect
    Entities. Multiple  func_trains may be  assigned to one  path, but
    they should each have a different starting path_corner.

    To destroy a func_train  leaving only the original brushes, select
    the  func_train, and  choose Ungroup  Entities from  the Selection
    menu.

    Note that  func_trains are positioned  differently in SEB  than in
    Quake.  Quake ignores the placement of the func_train in space and
    requires an origin specification.  SEB simply uses the location of
    the  first path_corner  to  define the  origin.   When creating  a
    moving  object, just place  it at  the beginning  of its  path and
    everything should work out.

worldspawn

    Of  course SEB  supports the  worldspawn entity,  but none  if its
    attributes have any effect.



* THE GOAL

Goals are  represented as invisible  detail lumps -- basically  a lump
that can be neither seen to felt is used to signal a win.  If the ball
falls ENTIRELY within an invisible  detail lump it will trigger a goal
event.

You may create  whatever geometry you like to  visually and physically
represent the goal.  You may even make it move.



* ADDING MATERIALS

SEB uses the standard OpenGL lighting model rather than a script-based
shading system  like Quake's.   But when we  create maps for  SEB it's
important to be able to see  what the textures are going to look like,
so we must create a simple Quake shader for each SEB material in order
to fool radiant.  SEB does not use this shader directly.

Creating a material is a 3-step process.

    1) Create the texture image.
    2) Create the bogus shader.
    3) Create the material file.

1)  The texture  must be  an image  in JPEG format.   It may come from
    anywhere.  Its width and height must both be powers of two.

    For  this  discussion, let  us  assume  you  have an  image  named
    wood.jpg.  Place in it seb/data/mtrl/.

2)  Edit the file mtrl.shader, adding an entry for your new image.

    textures/mtrl/wood
    {
        {
            map textures/mtrl/wood.jpg
        }
    }

    The shader name  (on the first line) is the  name by which radiant
    will refer to  the material.  It must match  the texture file name
    (on  the fourth  line) minus  the ".jpg"  suffix.   Otherwise, SEB
    won't be able to find it.

3)  Create a  material file in sep/data/mtrl, in  this case mtrl/wood.
    This name must match the radiant shader name, minus the "texture/"
    prefix. The file must contain 17 values, explained below.

       1.0 1.0 1.0 1.0
       1.0 1.0 1.0 1.0
       0.2 0.2 0.2 1.0
       0.0 0.0 0.0 1.0
       0.0

After having completed these 3 steps, do a "Flush & Reload Shaders" in
radiant.  Your new material should appear among the mtrl shaders.


Those 17  values define the material  in terms of  the stardard OpenGL
material model.  They define not only  the color of  the material, but
how it reacts  to different types of lighting  and different points of
view.  Their meaning is a follows:

  - The first line  gives the diffuse material color (R  G B A).  This
    is  the basic  color of  the material  resulting  from directional
    light falling upon it.  The fourth component is the alpha channel.
    0 is transparent, 1 is opaque.

  - The second  line gives  the ambient material  color. It  gives the
    color  of the  material  resulting from  nondirectional light.  It
    doesn't make much of a contribution in practice.

  - The third  line gives  the specular material  color.  This  is the
    color of the material  when directional light is glinting directly
    off of it into the eye of  the user. A bright white here will make
    an object look shiny, while a  darker color will give the object a
    matte appearance.

  - The  fourth line gives  the emissive  material color.   This color
    contributes  to the  appearance of  the object  regardless  of the
    light falling  upon it.  A bright  color here will  make an object
    appear to glow in darkness, or at least appear to be unaffected by
    external light.

  - The  fifth  line gives  the  material  shinyness.  Simply put,  it
    defines the size of the  specularity on an object.  0 will produce
    a dull finish, while 128 will produce a very tight specularity.
 
The five of  these togather determine the base  color of the material.
This base color is then blended with (added to) the texture color.



* CAVEATS

The SEB physics  engine can take pretty much anything  you throw at it
without breaking down, but there are a few problem areas.

If a  ball gets squished by a  moving object, it will  probably end up
moving  into  and  through  a  solid, possibly  getting  stuck  there.
There's just no  easy solution to this problem.  The physical analogue
would be  to have the offending  moving object stop  moving.  But then
what?   Nothing  moves, nothing  changes,  and  the problem  certainly
doesn't resolve itself.

Currently, the best solution is to stick with the unreal behavior.  At
least it keeps things  moving.  Mappers should actively avoid creating
situations in which this unreal behavior is made apparent.

  - If you have an elevator moving  up and down, prevent the ball from
    standing  underneath.   Either make  the  elevator  shaft a  solid
    (potentially invisible) object, or make it a bottomless pit.

  - If  you have platforms  moving horizontally,  for example  a ferry
    across a gap, ensure that a ball falling off the platform into the
    gap falls all the way out of the platform's path by making the gap
    deep.

  - If you have a Quake-ish crusher, delete it.  There's just no place
    for something like that in  SEB because the ball doesn't "die", it
    merely falls.


Have fun.  Problems?  Contact <rlk@snth.net>
